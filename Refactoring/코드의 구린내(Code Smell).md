## 중복 코드

중복코드는 구린내의 제왕이라고 한다.ㅋㅋ

똑같은 코드 구조가 두 군데 이상 있을 때는 해당 부분을 하나로 통일하면 프로그램이 개선된다.

### 1. 한 클래스의 두 메서드 안에 같은 코드가 들어있는 경우

메서드 추출(Extract Method)기법을 적용하면 된다.

겹치는 코드를 빼내어 별도의 메서드로 만든다.

그 후 그 메서드를 두 곳에서 호출하면 된다.

### 2-1. 한 클래스의 두 하위 클래스에 같은 코드가 들어 있는 경우

1. 메서드 추출(Extract Method) 기법을 적용해서 중복을 없앤다.
2. 메서드 상향(Pull Up Method) 기법을 적용한다.

### 2-2. 코드가 똑같지 않고 비슷한 경우

1. 메서드 추출(Extract Method) 기법을 적용해서 같은 부분과 다른 부분을 분리한다.
2. 템플릿 메서드 형성(Form Template Method) 기법을 적용한다.

### 3. 두 메서드가 알고리즘만 다르고 기능이 같은 경우

1. 두 알고리즘 중에서 더 간단한 것을 택한다.
2. 알고리즘 전환(Substitue Algorithm)기법을 적용한다.

### 4. 중복 코드가 메서드 가운데 있는 경우

1. 주변 메서드 추출(Extract Surrounding Method)기법을 적용한다.

### 5. 서로 상관없는 두 클래스 안에 중복코드가 있는 경우

1. 한 클래스 안의 중복 코드를 클래스 추출(Extract Class)하거나 모듈 추출(Extract Module)을 적용한다.
2. 제 3의 클래스나 모듈로 떼어낸 후 그것을 다른 클래스에서 호출한다.

1. 중복코드를 빼서 메서드로 만든다.
2. 그 메서드를 두 클래스 중 하나에 넣고 다른 클래스에서 그 메서드를 호출하거나, 코드를 빼내어 만든 메서드를 제 3의 클래스에 넣고 그걸 두 클래스에서 호출한다.

## 장황한 메서드

최적의 상태로 장수하는 객체 프로그램을 보면 공통적으로 메서드의 길이가 짧다.

나도 책을 읽으며 고민했던 부분인데, OOP로 작성된 프로그램을 보면 기능이 거의 없는 메서드가 서로 끊임없이 위임하는게 (의미없다고 생각될 정도로) 아닌가 싶은 생각이 들 때도 있다.

하지만, 시간이 지나면서 유지보수나 새로운 기능을 추가할 때 이러한 작은 메서드의 중요성을 실감했다.

나도 포함해서 보통의 사람들은 프로시저가 길수록 이해하기 어렵다는 점을 안다.

하지만 하위 루틴을 호출 할 때 오버헤드가 수반되기 때문에 짧은 메서드를 본능적으로 기피하게 된다.

물론 현대의 객체지향 언어는 프로세스 내부 호출에 따른 오버헤드가 현저히 줄었지만, 

이제 하위 프로시저의 기능을 알려면 환경 전환을 해야하므로(기능을 이해하기 위해 메서드를 따라 내려가서 읽어야 하는 경우) 

코드를 보고 이해하려는 사람들의 머릿 속에 오버헤드가 생겼다. ㅋㅋ

다들 이해할 것이다. 간단하게 Spring의 내부 코드만 보더라도, 하나의 기능을 이해하기 위해 수많은 메서드를 따라 내려가야 한다. 그러다보면 내가 무슨 기능을 이해하려 이 메서드를 보고 있는지 목적을 잊게 된다.

즉, 여기서 말하고 싶은 이야기는 **짧은 메서드를 이해하기 쉽게 하려면 메서드 명을 잘 정해야 한다**.

메서드 명을 한눈에 알 수 있게 작성하면 메서드 안의 코드를 분석하지 않아도 된다.

이를 위해서는 메서드를 훨씬 과감하게 쪼개야 한다.

메서드 명은 아래와 같이 작성해야 한다.

> 메서드 명은 기능 수행방식이 아닌, 목적(기능 자체)을 나타내는 이름으로 정한다.

이제 메서드를 과감하게 쪼개는 기준에 대해 설명해보자
### 1. 메서드를 줄이자

메서드를 줄이려면 십중팔구 메서드 추출(Extract Method)기법을 사용해야 한다.

### 2. 메서드에 매개변수와 임시변수가 많은 경우

이런 경우 메서드 추출을 하기 힘들다.

그렇다면 매개변수와 임시변수를 제거해야 한다.

아래는 그 방법에 대해 설명한다.

1. 임시변수를 메서드 호출로 전환(Replace Temp with Query)기법이나 임시변수를 메서드 체인으로 전환(Replace Temp with Chain)기법을 적용하면 임시변수가 제거된다.

2. 길게 열거된 매개변수는 매개변수 세트를 객체로 전환(Introduce Parameter Object)기법과 객체를 통째로 전달(Preserve Whole Object) 기법을 적용한다.

위의 방법들을 적용했음애도 임시변수와 매개변수가 많은 경우 3번 방법을 이용한다.

3. 메서드를 메서드 객체로 전환(Replace Method with Method Object)기법을 적용한다.

### 3. 코드를 여러 덩어리로 분리하기 위한 방법

1. 주석을 찾는다.
2. 기능 설명이 주석으로 처리된 코드 구간을 메서드로 만든다.
3. 메서드 명은 주석에 설명된 기능을 참고해서 정한다.

### 4. 조건문과 루프를 메서드로 뺀다.

1. 조건문은 조건문 쪼개기(Decompose Conditional)기법을 사용한다.

2. 루프를 컬렉션 클로저 메서드로 전환(Replace Loop with Collection Closure Method)기법을 실시 한 후 클로저 메서드 호출과 클로저 자체에 메서드 추출(Extract Method)기법을 실시한다.

## 방대한 클래스

기능이 지나체기 많은 클래스에는 보통 엄청난 수의 인스턴스 변수가 들어 있다.

클래스에 인스턴스 변수가 많으면 중복코드가 반드시 존재하기 마련이다.

### 1. 인스턴스 변수를 하나로 묶자

1. 클래스 추출(Extract Class) 기법을 실시하면 수 많은 인스턴스 변수를 하나로 묶을 수 있다.

서로 연관된 변수를 골라서 클래스로 추출하면 된다.

예를 들어 `depositAmount`와 `depositCurrency`는 한 클래스로 추출하는게 좋다.

일부 변수가 접두어나 접미어가 같은 경우 하나의 클래스로 추출하자.

2. 하위 클래스로 추출하는 것이 적합할 것 같으면 하위 클래스 추출(Extract Subclass)기법을 실시한다.
3. 추출할 클래스가 대리자로 부적절할 것 같으면 모듈 추출(Extract Module)기법을 실시한다.

### 2. 인스턴스 변수를 계속해서 모두 사용하지 않는 클래스

1. 클래스 추출, 모듈 추출, 하위클래스 추출 중 하나를 여러번 적용한다.

### 3. 코드 분량이 너무 많은 클래스

1. 제일 간단한 해결책은 그 클래스 자체에서 중복 코드를 없애는 것이다.

예를 들어 중복코드 100줄짜리 메서드 5개가 있다면 100줄을 2줄 짜리 메서드 10개로 만들고 

그 10줄의 코드가 들어있는 메서드 5개로 만들면 된다.

2. 일반적으로 클래스 추출, 모듈 추출, 하위클래스 추출 중 하나를 실시하면 된다.
클라이언트가 그 클래스를 어떻게 사용할지  결정하고, 그 각 사용법마다 인터페이스 추출을 실시하는 편법도 자주 쓰인다.

3. 방대한 클래스가 GUI클래스인 경우, 데이터와 기능을 서로 다른 도메인 객체로 옮긴다.
   일부 중복데이터는 놔두고 그 데이터와 싱크를 유지해야하는 경우 관측 데이터 복제(Duplicate Observed Data)기법을 실시한다.
구 버전의 AWT 컴포넌트를 사용한다면 그 기법을 적용해서 GUI클래스를 없애고 Swing 컴포넌트로 대체하면 된다.

## 과다한 매개변수

필요한 데이터가 없을 때는 다른 객체에게 데이터를 가져오게 요청하면 된다.

객체를 사용할 때는 메서드에 필요한 모든 데이터를 전달하는게 아니라, 그 모든 데이터를 가져올 수 있는 메서드만 전달하면 된다.

1. 이미 알고있는 객체에 요청하여 한 매개변수에 들어있는 데이터를 가져올 수 있을 때는 매개변수 세트를 메서드로 전환(Replace Parameter with Method)을 적용하면 된다.
이 객체는 인스턴스 변수일 수도 있고 다른 매개변수일 수도 있다.

2. 객체에 있는 데이터 세트를 가져온 후 데이터 세트를 그 객체 자체로 변환하려면 객체를 통째로 전달(Preserve whole Object)을 적용하면 된다.
3. 여러 데이터 항목에 논리적 객체가 없다면, 매개변수 세트를 객체로 전환(Introduce Parameter Object)을 적용하면 된다.

이 기법들을 적용시 예외가 하나 있다.
호출되는 개체가 호출 객체에 의존하면 안될 때다.
이럴 때는 데이터를 개별적으로 빼서 매개변수로 전달하는 것이 바람직하지만 그렇게 하기에는 어려움이 따른다.

나열된 매개변수 세트가 너무 길거나 자주 바뀐다면 불가피하게 종속구조를 유지하는 것도 생각해봐야 한다.

## 수정의 산발

수정의 산발이란 한 클래스가 다양한 원인 때문에 다양한 방식으로 자주 수정될 때 일어난다.

예를 들어 새 데이터 베이스를 생성할 때마다 3개의 메서드를 수정해야 하고, 새 금융상품을 추가할 때마다 4개의 메서드를 수정해야하는 경우이다.
그런 경우 하나의 클래스를 여러 개의 변형 객체로 분리하는 것이 좋다.

그러면 각 객체는 한 종류의 수정에 의해서만 변경된다.

변경할 때는 한 개의 클래스나 모듈만 변경해야 한다.

새 클래스나 모듈 안에는 반드시 그 변경사항을 표시해야 한다.

정리하자면, 특정 원인으로 인해 변하는 모든 부분을 찾은 후 클래스 추출(Extract Class)기법을 적용해서 그 부분들을 합치고 하나의 클래스로 빼내야 한다.

## 기능의 산재

기능의 산재는 수정의 산발과 비슷하지만 정 반대이다.

수정할 때마다 여러 클래스를 수정해야한다면 이 문제를 의심해야 한다.

수정의 산발은 한 클래스 내에서 여러 수정이 발생하는 문제이고, 기능의 산재는 하나의 수정으로 여러 클래스가 바뀌게 되는 문제이다.

아무튼, 기능의 산재 문제가 발생하는 경우, 
1. 메서드 이동, 필드이동을 적용해서 수정할 부분들을 전부 하나의 클래스 안에 넣어야 한다.

2. 기존의 클래스 중 어느 것에도 넣기에 부적절할 때는 새 클래스를 만들어야 한다.
3. 대개는 클래스 내용 직접 삽입(Inline Class)을 적용해서 별도 클래스에 분산되어 있는 모든 기능을 한 곳으로 가져와도 된다.

## 잘못된 소속

객체의 핵심은 데이터와 그 데이터에 사용되는 프로세스를 한 데 묶는 기술이라는 점이다.

전통적으로 어떤 메서드가 자신이 속하지 않는 클래스에 더 많이 접근한다면 잘못된 소속의 구린내가 풍긴다.

잘못 소속된 메서드가 가장 많이 접근하는 대상은 데이터다.

이러한 문제에 대한 해결책을 제시하고자 한다.

### 소속이 잘못된 메서드

메서드는 더 많이 접근하는 클래스에 들어가는 것이 마땅하다.

즉, 메서드 이동 기법을 실시해서 더 자주 접근하는 클래스로 옮겨야 한다.

### 일부 소속이 잘못된 경우

메서드의 일부분만 소속이 잘못된 경우는 메서드 추출을 적용한 후 메서드 이동을 적용해서 적절한 클래스로 옮긴다.

### 한 메서드가 여러 클래스에 들어 있는 기능을 이용하는 경우

이럴 땐 어떤 메서드로 옮겨야 할까?

문제의 메서드가 접근하는 데이터가 어느 클래스에 가장 많이 들어 있는지 파악해서 그 클래스로 옮긴다.

그러기 전에 먼저 메서드 추출을 실시해서 그 메서드를 다른 클래스에 들어갈 여러 부분으로 쪼개면 작업이 더 쉬워진다.

### 위의 규칙을 따르지 않는 복잡한 패턴

전략패턴, 방문자 패턴, 자가위임 패턴이 위의 규칙을 따르지 않는 복잡한 패턴이다.

이 패턴들은 수정의 산발(하나의 클래스에 여러 수정이 필요한 경우)이 의심될 때 해결책으로 쓰인다.

기본 규칙은 함께 수정되는 것들을 하나로 뭉치는 것이다.

전략 패턴과 방문자 패턴은 재정의가 필요한 일부 기능들을 따로 빼내기 때문에 기능을 수정하기는 편해지지만, 인다이렉션이 늘어나는 단점이 있다.

## 데이터 뭉치

데이터 항목은 몰려다니는 습성이 있다.

데이터 뭉치는 객체로 만들어야한다.

우선 데이터 뭉치가 필드처럼 보이는 부분을 찾아야 한다.

이 데이터들을 객체로 전환하기 위해서 클래스 추출 기법을 사용한다.

그리고 나서 메서드 시그니처를 대상으로 `매개변수 세트를 개체로 전환 기법`과 `객체를 통째로 전달 기법`을 적용해 간결하게 만든다.

이렇게 하면 매개변수가 적어져서 부수적으로 메서드 호출 코드가 간결해지는 효과도 생긴다.

### 새로 생긴 객체의 속성들 중 일부만 이용하는 데이터 뭉치

둘 이상의 필드를 객체로 전환하면 코드가 개선된다.

그러한 효과는 여러 데이터 값 중 하나를 삭제해보면 알 수 있다.

그렇게 했을 때 나머지 데이터 값들이 제대로 돌아가지 않는다면 그 객체를 없애고 새로 만들어야 한다.

인스턴스 변수 세트와 매개 변수 세트를 줄이면 의심되는 문제점도 없어지지만, 일단 객체로 전환하고 나면 전체적인 성능이 개선될 여지가 있다.

이렇게 하면 잘못된 소속(feature envy)의 구린내가 풍기는 부분들도 찾을 수 있는데, 이 구린 부분들은 새 클래스로 빼내면 된다.

## 강박적 기본 타입 사용

이 소분류 챕터를 요약하자면, "일정 개수 이상의 기본 타입을 묶어서 사용해야 한다면 객체로 변환하자." 가 되겠다.

대개 프로그래밍 환경을 구성하는 데이터는 두 종류이다.

하나는 레코드 타입인데, 이것을 사용해서 데이터를 의미 있는 그룹들로 묶어 구조화할 수 있다.

기본 타입은 한마디로 초석이라고 할 수 있다.

레코드에는 항상 일정 양의 오버헤드가 따른다.

레코드란 데이터베이스 테이블일 수도 있지만, 그 외의 것이라면 한두 가지 목적만을 위해 생성하기엔 어중간할 수도 있다.

객체의 주요한 장점중 하나가 바로 기본타입 클래스와 응용 클래스 간의 경계를 허문다는 점이다.

객체를 처음 접하는 사람은 보통 숫자와 통화를 연동하는 돈 관련 클래스나 전화번호와 우편번호 같은 특수 문자열 클래스 등의 사소한 작업에 작은 객체를 잘 사용하지 않으려는 경향이 있다.

이런 실수를 하지 않으려면 데이터 값을 객체로 전환(Replace Data Value with Object)를 실시한다.

### 데이터 값이 분류부호인 경우

그 값이 기능에 영향을 주지 않는다면 분류부호를 클래스로 전환한다.(Replace Type Code with Class)

### 조건문에 분류 부호가 사용될 때

분류부호를 하위 클래스로 전환(Replace Type Code with Subclasses)기법을 적용한다.

### 기본 타입이 매개변수 세트에 들어 있는 경우

매개변수 세트를 객체로 전환(Introduce Parameter Object)기법을 적용한다.

### 배열때문에 불편한 경우

배열을 객체로 전환(Replace Array with Object)기법을 적용한다.

## Switch 문

객체지향코드의 특징 중 하나는 swich-case문이 비교적 적게 사용된다는 점이다.

switch문의 단점은 반드시 중복이 생긴다는 점이다.

switch문에 새 코드를 행을 추가하려면 그렇게 여기저기에 존재하는

