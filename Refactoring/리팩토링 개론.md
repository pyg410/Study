## 리팩토링은 무엇인가

리팩토링은 문맥에 따라 두 가지 의미로 정의된다.
1. 겉으로 드러나는 기능은 그대로 둔 채, 알아보기 쉽고 수정하기 간편하게 소프트웨어 내부를 수정하는 작업.(명사)
2. 리팩토링 기법을 연달아 적용해서 겉으로 드러나는 기능은 그대로 둔 채 소프트웨어 구조를 변경한다.(동사)

정의를 통해 강조하고자 하는 것은 두 가지다.

첫째, 리팩토링의 목적은 소프트웨어를 더 이해하기 쉽고 수정하기 쉽게 만드는 것이다.
리팩토링은 성능 최적화와 상반된다.
물론 성능최적화를 할 때도 대개는 기능이 변경되지 않으면 단순히 내부 구조만 바뀐다.(속도가 빨라진다.)

그러나 리팩토링과 성능 최적화는 목적이 다르다.

성능 최적화를 수행하면 코드를 더 파악하기가 더 어려워질 때가 많지만, 필요한 성능을 얻으려면 어쩔 수 없이 해야한다.

둘째, 리팩토링은 겉으로 드러나는 소프트웨어 기능에 영향을 주지 않는다.

## 켄트 벡의 '모자 두 개'

소프트웨어 개발에 리팩토링을 적용할 때 기능 추가와 리팩토링이라는 별개의 두 작업에 시간을 분배해야 한다.

**기능을 추가**할 땐 코드를 수정하지 말고 **기능만 추가**해야 한다.

진행 상태를 파악하려면 테스트를 추가하고 그 테스트들이 제대로 되는지 알아내면 된다.

**리팩토링**할 때는 코드를 추가하지 말고 **코드 구조 개선만** 해야 한다. 앞서 실수한게 없다면 테스트는 전혀 추가하지 말고 오로지 코드 구조만 수정해야 한다.

추가로, 인터페이스가 변경되어 그에 맞게 **코드를 고치는 것이 불가피할 땐 테스트만 변경**해야 한다.

소프트웨어를 개발하다보면 기능 추가 모자와 리팩토링 모자를 자주 바꿔쓰게 된다.

처음에 새 기능을 추가하다가, 그 코드의 구조를 바꾸면 작업이 훨씬 쉬워지겠다는 생각이 들어 작업을 멈추고 

잠시 리팩토링 작업으로 전환한 후, 구조 변경이 끝나면 다시 새 기능 추가 작업으로 전환하고, 

새 기능이 제대로 돌아가면 그 기능을 이해하기 어려운 구조로 작성했다는 생각이 들어 

다시 리팩토링 작업으로 전환하는 식으로 두 모자를 바꿔쓰게 된다.

즉, 기능 추가 -> 리팩토링 -> 기능 추가 -> 리팩토링 -> 반복

이 모든 작업은 10분정도 간단한 작업일 수도 있지만, 이 시간동안 각 작업이 완료될 때까지 반드시 본인이 현재 하고 있는 작업의 일관성을 유지해야한다.

## 리팩토링은 왜 해야 할까

### 1. 소프트웨어 설계가 개선된다.

리팩토링이 진행되지 않으면, 프로그램 설계는 점점 노후된다.

단기적인 목적 때문에 코드를 수정하거나 코드의 설계를 완벽히 이해하지 않고 코드를 수정하면, 코드 구조가 뒤죽박죽되어 그 코드를 보고 설계를 파악하기가 어려워진다.

리팩토링은 산만해진 코드를 정리하는 작업이다.

즉, 부적절한 위치에 있는 코드를 제거하는 것.

코드 설계를 파악하기 힘들수록 설계를 보수하기도 힘들어지니 결국 설계가 더 엉망으로 되는 악순환의 고리가 끊기지 않는다.

그러니 코드의 처음 설계 구조를 유지하려면 정기적으로 리팩토링을 실시해야 한다.

코드 설계가 깔끔하지 않으면 보통 기능이 같은 코드가 여기저기 중복되어 있어서 쓸데없이 코드만 길어진다.

설계를 개선하는 주요 비법 중 하나는 바로 그런 중복 코드를 없애는 것이다.

코드 양이 줄어어도 시스템이 빨라지지는 않지만 코드 수정은 훨씬 쉬워진다.

### 2. 소프트웨어를 이해하기가 더 쉬워진다.

프로그래밍에서는 개발자가 원하는 바를 정확히 명령하는 것이 중요하다.

하지만 본인이 작성한 코드를 이용하는 대상은 컴퓨터만 있는 것이 아니다.

공동프로젝트라면 다른 팀원이 2~3개월 안에 본인의 코드를 신속히 파악해서 수정해야하는 경우도 생긴다.

개발자는 이렇게 다른 사람이 코드를 수정하는 경우까지 고려하지 못하는 실수를 하기 쉬운데, 알고보면 이런 코드 이해 대상을 두루 고려하는 일이 제일 중요하다.

리팩토링을 실시하면 코드는 더 파악하기 쉬워진다.

리팩토링은 제대로 실행되지만 구조가 완전하지 못한 코드에 대해 실시하는 것이다.

그렇다고해서 지나치게 타인 위주로 고려해가며 프로그래밍할 필요는 없다.

보통은 최초의 코드 작성자 본인이 자기 코드를 수정하는 것이 대부분이기 때문이다.

코드를 이해하기 쉽게 만들면 좋은 점이 또 있다.

리팩토링을 실시하면 낯선 코드를 쉽게 이해할 수 있다.

> 난 어떤 코드를 처음 보면서 파악해야할 때 그것의 기능부터 파악한다. 코드 몇줄을 보고 혼잣말로 "그렇구만. 이 코드의 기능은 이거군"하고 되뇐다. 
> 그렇게 이해하고 생각했던 내용을 리팩토링하는 내내 계속 떠올리며 반영한다. 
> 나는 코드를 수정해서 내가 이해한 내용을 더 꼼꼼히 반영한 후, 다시 실행해서 코드가 여전히 제대로 실행되는지 확인하면서 처음에 파악했던 기능을 점검한다.
> 초기에 그런 식으로 세부적인 요소에 대해 리팩토링했다. 그렇게 첫 리팩토링을 마쳐서 코드가 깔끔해지면 기존에 안보이던 설계가 보인다.
> - 리팩토링 책 일부 발췌

> 리팩토링은 우선 창 밖이 보이게 뿌연 유리창부터 닦는 일 - Ralph Johnson

### 3. 버그를 찾기 쉬워진다.

코드를 파악하기 쉬우면 버그 발견도 쉬워진다.

프로그램 구조가 명료해지면서 버그도 쉽게 찾아지는 것이다.

### 4. 프로그래밍 속도가 빨라지니까

의아할 수 있다.

리팩토링을 하면 코드 품질이 좋아지는 것은 쉽게 이해된다.

설계 개선, 가독성 향상, 버그 감소 등은 코드의 질을 높여준다.

하지만 개발 속도가 왜 빨라질까?

리팩토링을 하면 설계가 개선된다.

노후화된 설계에서 개발 속도는 초기에 잠깐 빠를 수 있지만, 얼마 못가서 개발 속도가 떨어진다.

버그 찾기에 시간을 낭비하게 된다. 또한 그것을 해결하기위해 중복코드를 찾아내느라 수정 시간이 길어진다.

즉, 원래의 코드를 반복적으로 패치해야해서 코드가 길어질 수 밖에 없다.

## 리팩토링은 언제 필요한가?

리팩토링은 일부러 시간내서 하지는 말라고 한다.

따로 시간을 정해 하는 것이 아닌, 일상적으로 틈틈이 해야한다.

뭔가 다른 걸 해야하는데 리팩토링을 실시하면 그 작업이 쉬워지기 때문에 하는 것이다.

### `Don Roberts`의 리팩토링 시점 판단법

어떤 작업을 처음 할 땐 그냥 하고, 비슷한 작업을 두 번째 해야 할 땐 중복작업이라 좀 망설여져도 그냥 하고, 세번 째 하게 되면 그때 리팩토링을 실시하는 것이다.

### 1. 기능을 추가할 때

소프트웨어에 새 기능을 추가해야하는 상황은 리팩토링이 절실히 필요한 첫 번째 상황이다.

이 시점에 해야하는 이유
1. 코드를 이해하기 쉽게 만들기 위해서이다.
그 코드가 과연 리팩토링한다고 더 이해하기 쉬워질지 충분히 고민한 후 확신이 들면 리팩토링해야한다.
**코드를 깔끔하게 만드는 과정에서 더 깊이 이해하게 된다.**

2. 설계가 지저분해서 어떤 기능을 추가하기 힘들기 때문이다.
설계를 보고 "이 코드를 이런 식으로 설계했다면 이 기능을 추가하기 쉬울 텐데"하는 생각이 들 땐 리팩토링을 실시해서 설계를 수정해야한다.

### 2. 버그를 수정할 때

버그를 수정할 땐 주로 코드를 이해하기 쉽게 만들려고 리팩토링한다.

버그 리포트를 받았을 정도면 여태까지 버그가 있는 줄도 몰랐을 만큼 그 코드가 지저분하다는 반증이다.

### 3. 코드를 검수할 때

코드 검수를 통해 방대한 소프트웨어 시스템의 더 많은 부분을 더 많은 사람이 이해하게 된다.

코드 검수는 명료한 코드를 작성하기 위해서도 꼭 필요하다.

이를 통해 많은 아이디어를 제안받을 기회도 생긴다.

리팩토링을 하게 된다면, 다른 사람이 개발한 코드를 검수하기도 쉬워진다.

리팩토링을 통해 생각난 아이디어를 특정 코드에 쉽게 구현할 수 있을지 고민해서 가능하다고 판단되면 리팩토링을 진행한다.

이를 통해 리팩토링 후에 어떤 구조로 변할지도 알 수 있다.

리팩토링을 진행하면 코드 검수 결과도 더 구체적으로 나온다.

만약 페어프로그래밍을 진행한다면 코드 검수와 그에 따른 리팩토링이 동시에 진행된다.

## 리팩토링의 효용성 - Kent Beck

프로그램이 지닌 가치는 두 종류다.
1. 현재의 기능
2. 미래의 기능

프로그래밍할 때 개발자는 주로 그 프로그램에 현재 무슨 기능을 넣을지에 전념한다.
버그를 수정하든 새 기능을 추가하든, 그것은 프로그램의 성능을 높임으로써 현재 기능의 가치를 높이는 일이다.

프로그램의 현재 기능은 그저 일부에 불과하다는 사실을 깨우치지 않으면 개발자로서 오래가지 못한다.

**오늘 일을 오늘 할 수 있어도 내일 일을 내일 할 능력이 없다면 개발자로서 실패하게 된다.**

리팩토링을 실시하면 이런 곤경에서 벗어날 수 있다.

**과거의 판단이 현재를 기준으로 불합리하다는 사실을 발견했다면 그 판단을 수정해야한다.**

프로그램은 다음 4가지 상황일 때 수정하기 힘들어진다.
1. 코드를 알아보기 힘들 때
2. 중복된 로직이 들어 있을 때
3. 추가 기능을 넣어야 해서 실행중인 코드를 변경해야 할 때
4. 조건문 구조가 복잡할 때

그러므로 프로그램은 **코드를 알아보기  쉽고, 모든 로직이 한 곳에 있으며, 기존 기능을 건드릴 필요 없이** 조건문 구조가 최대한 간결하게끔 작성해야 한다.

리팩토링은 실행 중인 프로그램의 기능을 바꾸는 작업이 아니고 신속한 개발 공정을 가능하게 하는 이런 성질을 가중하면서 가치를 높이는 일이다.

## 인다이렉션 과 리팩토링 - Kent Beck

> 컴퓨터 과학에선 모든 문제의 해결책이 인다이렉션 계층을 하나 더 만드는 것이라고 가르친다 - Dennis DeBruler

소프트웨어 공학자들은 인다이렉션을 광적으로 좋아한다는 점에서 볼 때 대부분의 리팩토링을 적용하면 프로그램에 생각 외로 많은 인다이렉션이 들어가는 것도 어쩌면 당연하다.

> 인다이렉션이란?
> 인다이렉션은 어떤일을 내가 직접하는 것이 아니라 다른 사람에게 부탁한다는 의미이다. 어떤 코드를 작성했는데, 이 코드가 다른 코드를 호출하고, 다른 코드는 또 다른 코드를 호출해서 내가 직접 처리하지 않지만 여러 경로를 거쳐 결국에 결과를 가져오는 식이다.

리팩토링은 방대한 객체와 장황한 메서드를 잘게 쪼개는 경향이 있다.

그러나 인다이렉션은 양날의 검이다. 한 부분을 둘로 쪼개면 관리할 부분이 늘어나기 때문이다.

한 객체가 다른 객체에게 작업을 위임하고, 그 객체가 또 다른 객체에게 작업을 위임하기 때문에 코드가 알아보기 힘들어질 수도 있다.(지나친 추상화)

그러므로 인다이렉션을 사용하는 것은 가능하면 자제하는 것이 좋다.

물론 인다이렉션도 다음과 같은 장점이 있다.
1. 로직을 공유한다 : 두 위치에서 호출되는 하위 메서드나 모든 하위클래스가 공유하는 상위클래스의 메서드 등이 있다. 이런 식으로 **하나의 로직을 여러 곳에서 공유**할 수 있다.
2. 의도와 구현부를 따로 나타낸다 : **클래스명과 메서드명을 정해서 의도한 바**를 드러낼 수 있고, 클래스나 메서드의 내부 코드를 통해 그 **의도를 어떻게 구현했는지** 보여줄 수 있다.
   내부 코드를 잘게 쪼개어 의도적인 측면에서 작성했다면, 그 코드 구조에 대한 **주요정보를 잘 드러내는 코드를 작성**할 수 있다.
3. 수정 부분을 분리한다 : 한 객체를 두 위치에 사용했는데 두 경우 중 한 상황에 대해 동작을 수정해야 할 때 그 객체를 수정하면 두 상황이 모두 변경될 위험이 있다. 따라서 우선 하위클래스를 만들고 변하는 경우에 참조하게 만들자. 예기치 못하게 변할 위험을 감수하지 않고 클래스를 수정할 수 있다.
4. 조건문을 코드화 : 객체에는 재정의 메시지라는 우수한 메커니즘이 존재한다. 조건문을 유연하면서 분명하게 표현할 수 있다. 조건문을 메시지로 바꾸면 중복 코드가 줄어들어 명료해지며 동시에 유연성도 높아진다.

리팩토링 게임을 생각해보자.

시스템의 현재 동작을 유지하면서 시스템의 품질을 높이거나 비용을 절감하는 식으로 시스템의 가치를 높이려면 어떻게 해야 할까?
1. 프로그램을 살펴본다.
프로그램을 살펴보고, 리팩토링을 실시하여 개발자의 추측이 빗나갈 위험을 예방한다.
프로그램은 언제나 처음 기능이 그대로 유지된다. 또한 코드에 중요한 성질을 부여할 수 있다.

2. 불필요한 인다이렉션을 찾아 없앤다.
기존에 어떤 목적으로 사용되었는데 현재는 쓸모 없게 된 중개 메서드(intermediate method), 또는 원래 공유하거나 재정의할 계획이었으나 결국 한 곳에서만 사용하게 바꾼 컴포넌트가 주로 발견되는 불필요한 인다이렉션이다.
숨어있는 인다이렉션을 발견했다면 인다이렉션을 없앤다.

## 리팩토링 관련 문제들

### 데이터베이스

수많은 비지니스 애플리케이션은 바탕이 되는 데이터베이스 스키마와 강력히 결합되어있다.

이 때문에 데이터베이스 수정은 까다롭다.

아무리 데이터베이스 스키마와 객체 모델의 상호 의존성을 최소화하려고 계층구조로 시스템을 제작했더라도 데이터베이스 스키마를 수정하면 데이터도 이전해야하는데, 이건 시간도 오래걸리고 위험성도 높다.

이런 문제를 해결하기위해 객체 모델과 데이터베이스 모델 사이에 별도의 소프트웨어 계층을 두는 방법이 있다.

중계 계층이 생기면 복잡하긴 하나 상당한 유연성이 생긴다.

객체 모델의 일정 부분들이 변경될 가능성이 높다는 사실을 깨달았을 때 별도의 계층을 생성하면 된다.

### 인터페이스 변경

설명하기에 앞서 published interface에 대해 먼저 설명해야한다.

만약 interface의 이름을 변경한다면 캡슐화에 영향을 미친다.

interface내의 메서드를 사용하는 모든 코드에 접근이 가능하다면 문제가 생기지 않지만, 인터페이스를 사용되는 모든 부분을 찾는게 불가능하거나 수정할 수 없을 때 문제가 생긴다.

그런 경우 해당 인터페이스는 published interface가 된다.(public인터페이스보다 한 단계 더 공개된 - 마틴파울러)

한번 배포 타입이 된 인터페이스는 안전하게 수정이 불가능하다. 호출자만 수정하는 것이 불가능해지므로 더 복잡한 절차를 수행해야 한다.

그렇다면 published interface를 수정하는 리팩토링 기법들을 실시할 때는 어떻게 해야 할까?

그 인터페이스를 사용하는 부분이 그 인터페이스 변경에 맞춰 수정되기 전까지는 기존 인터페이스와 새 인터페이스를 모두 그대로 유지시켜야 한다.

기존 인터페이스가 새 인터페이스를 호출하게 하면 된다.

매서드 명을 변경할 때는 기존 메서드가 새 메서드를 호출하게 수정해서 계속 유지되게 해야 한다.

메서드 내용 자체를 복사해서는 안된다. 복사 붙여넣기를 하면 중복코드가 생겨서 오히려 문제를 만들게 된다.

자바의 deprecation 같은 타입을 작성해서 호출자에게 그 코드를 사용하지 말아야 함을 알려야 한다.

인터페이스를 유지하는 것은 가능하기는 해도 불편하고 까다롭다. 최소한 일정 기간 동안은 이러한 불필요한 메서드를 남겨둬야 하기 때문이다.

그러므로 꼭 필요할 때가 아니면 인터페이스를 published type으로 만들지 않는게 좋다.

이를 위해서는 인터페이스 수정을 촉진하기 위해 팀원이 다른 사람의 코드를 수정할 수 있게 코드 소유권 정책을 수정해야 할 수도 있다.

대체로 페어 프로그래밍을 이용하는 것이 좋다.

### 리팩토링하면 안 되는 상황

1. 대표적으로 코드를 처음부터 새로 작성해야하는 경우
코드가 돌아가지 않는다면 그건 새로 작성하라는 신호이다.
코드는 반드시 대부분 제대로 돌아가는 것이 우선이고, 리팩토링은 나중 일임을 명심하자.
한 가지 절충안은 강력한 캡슐화를 통해 여러 개의 컴포넌트로 나누는 것이다.
한 개의 컴포넌트씩 리팩토링할지 코드를 새로 작성할지를 결정하면 된다.
2. 마감일이 임박한 경우
마감일에 가까운 시점에 리팩토링해봤자 그로 인한 생산성은 마감일이 지난 후에야 가시화될 테니 쓸데 없다.

## 리팩토링과 설계

> 설계를 하면 생각이 아주 빨라지지만 그 생각엔 빈틈이 많다. - Alistair Cockburn

리팩토링을 하면 중점적인 작업이 달라진다.

사전설계는 해야하지만, 사전설계 과정에서 완벽한 솔루션을 찾을 필요 없이 적당한 솔루션만 생각하면 된다.

이를 통해 설계가 단순해진다.

모든 부분을 유연하게 만들려면 전체 시스템이 훨씬 복잡해지고 유지보수 비용도 높아지므로 시스템 전체를 유연하게 할 필요는 없다.

단순한 솔루션을 구현해놓고 그걸 나중에 유연한 솔루션으로 리팩토링하면 얼만큼 수고가 들지 스스로 고민해보자.

어려움이 없다고 판단되면 단순한 솔루션을 구현하면 된다.

즉, 단순한 솔루션 구현 후 필요에 따라 유연하게 리팩토링하면 되는 것이다.


## 리팩토링과 성능

소프트웨어 성능을 올리려면 먼저 소프트웨어를 튜닝 가능하게 만들어 놓고 나중에 충분한 속도가 나오게 튜닝하는 것이다.
이건 철저한 실시간 환경을 제외한 모든 환경에 적용된다.

빠른 소프트웨어를 작성할 수 있는 일반적인 세 가지 방법이 있다.
1. 철저한 실시간 시스템에 주로 사용되는 시간 분배
설계를 분해하면서 각 구성 요소에 시간이나 메모리 사용량 같은 자원별 예산을 할당한다.
각 컴포넌트는 할당된 시간을 상호교환하는 방식은 허용되지만 예산을 초과해선 안 된다.
즉, 철저한 성능시간이 핵심이다.
> 철저한 성능시간 : 프로그램 실행이 할당된 시간 내에 정확히 실행되어야 함을 의미한다.

2. 성능에 꾸준한 관심을 갖는다.
성능을 높이기 위함이지만, 이 방법은 그다지 효과는 없다.
직관적이긴 하지만, 성능을 높이기위해 수정한 것 때문에 프로그램에서 작업하기 힘들어지고 개발속도도 떨어진다.

3. **앞에서 언급한 90% 비율의 장점만 활용한다.**
성능 최적화 전까지는 성능에 신경쓰지 않고 프로그램을 잘 쪼개진 방식으로 제작한다.
성능 최적화 단계에서는 그 프로그램을 튜닝하는 특수 절차를 따른다.

우선 프로그램을 모니터링해서 그 프로그램이 시간과 공간을 소모하는 상황을 개발자에게 알려주는 프로파일러 하에서 프로그램을 실행해야 한다.

이러면 장점이 있다.
1. 성능 튜닝에 할애할 시간이 생긴다.(코드가 잘 쪼개져 있어 기능추가도 신속하다.)
2. 프로그램을 잘 쪼개면 성능을 분석할 때 더 정밀한 분석이 가능해진다.