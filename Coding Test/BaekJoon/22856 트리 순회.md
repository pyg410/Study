## ë¬¸ì œ

ë…¸ë“œê°€Â $N$ê°œì¸ ì´ì§„ íŠ¸ë¦¬ê°€ ìˆë‹¤. íŠ¸ë¦¬ë¥¼ ì¤‘ìœ„ ìˆœíšŒì™€ ìœ ì‚¬í•˜ê²Œ ìˆœíšŒí•˜ë ¤ê³  í•œë‹¤. ì´ë¥¼Â **ìœ ì‚¬ ì¤‘ìœ„ ìˆœíšŒ**ë¼ê³  í•˜ì.

ìˆœíšŒì˜ ì‹œì‘ì€ íŠ¸ë¦¬ì˜ ë£¨íŠ¸ì´ê³  ìˆœíšŒì˜ ëì€ ì¤‘ìœ„ ìˆœíšŒí•  ë•Œ ë§ˆì§€ë§‰ ë…¸ë“œì´ë‹¤. ì´ë•Œ ë£¨íŠ¸ ë…¸ë“œëŠ” í•­ìƒ 1ë²ˆ ë…¸ë“œì´ë‹¤.

ìœ ì‚¬ ì¤‘ìœ„ ìˆœíšŒëŠ” ë£¨íŠ¸ ë…¸ë“œì—ì„œ ì‹œì‘í•˜ë©°, ë‹¤ìŒê³¼ ê°™ì´ ì§„í–‰ëœë‹¤.

1. í˜„ì¬ ìœ„ì¹˜í•œ ë…¸ë“œì˜ ì™¼ìª½ ìì‹ ë…¸ë“œê°€ ì¡´ì¬í•˜ê³  ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì•˜ë‹¤ë©´, ì™¼ìª½ ìì‹ ë…¸ë“œë¡œ ì´ë™í•œë‹¤.
2. ê·¸ë ‡ì§€ ì•Šê³  í˜„ì¬ ìœ„ì¹˜í•œ ë…¸ë“œì˜ ì˜¤ë¥¸ìª½ ìì‹ ë…¸ë“œê°€ ì¡´ì¬í•˜ê³  ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì•˜ë‹¤ë©´, ì˜¤ë¥¸ìª½ ìì‹ ë…¸ë“œë¡œ ì´ë™í•œë‹¤.
3. ê·¸ë ‡ì§€ ì•Šê³  í˜„ì¬ ë…¸ë“œê°€ ìœ ì‚¬ ì¤‘ìœ„ ìˆœíšŒì˜ ëì´ë¼ë©´, ìœ ì‚¬ ì¤‘ìœ„ ìˆœíšŒë¥¼ ì¢…ë£Œí•œë‹¤.
4. ê·¸ë ‡ì§€ ì•Šê³  ë¶€ëª¨ ë…¸ë“œê°€ ì¡´ì¬í•œë‹¤ë©´, ë¶€ëª¨ ë…¸ë“œë¡œ ì´ë™í•œë‹¤.
5. ìœ ì‚¬ ì¤‘ìœ„ ìˆœíšŒë¥¼ ì¢…ë£Œí•  ë•Œê¹Œì§€ 1 ~ 4ë¥¼ ë°˜ë³µí•œë‹¤.

![](https://upload.acmicpc.net/ee01f435-9a8b-4d85-9720-4355f541fd4d/-/preview/)

ìœ„ ê·¸ë¦¼ì— ìˆëŠ” íŠ¸ë¦¬ì—ì„œ ì¤‘ìœ„ ìˆœíšŒë¥¼ í•œë‹¤ë©´Â 4â†’2â†’5â†’1â†’6â†’3â†’7$4 \rightarrowÂ 2 \rightarrow 5 \rightarrow 1 \rightarrow 6 \rightarrow 3 \rightarrow 7$Â ìˆœìœ¼ë¡œ ìˆœíšŒë¥¼ í•œë‹¤.

ë”°ë¼ì„œ,Â **ìœ ì‚¬ ì¤‘ìœ„ ìˆœíšŒì˜ ë**ì€ ë…¸ë“œ 7ì´ ëœë‹¤.

![](https://upload.acmicpc.net/c6cd786c-4235-499f-8ef2-57cdafd33ce7/-/crop/2544x1786/0,0/-/preview/)

**ìœ ì‚¬ ì¤‘ìœ„ ìˆœíšŒ**ëŠ” ìœ„ ê·¸ë¦¼ê³¼ ê°™ì´ ë£¨íŠ¸ì¸ ë…¸ë“œÂ 1$1$ì—ì„œ ì‹œì‘í•˜ì—¬ ë…¸ë“œÂ 7$7$ì—ì„œ ëë‚˜ê³ Â $1 \rightarrow 2Â \rightarrow 4 \rightarrowÂ 2 \rightarrow 5 \rightarrow 2 \rightarrow 1 \rightarrow 3 \rightarrow 6 \rightarrow 3 \rightarrow 7$Â ì´ì™€ ê°™ì€ ìˆœì„œë¡œ ìˆœíšŒë¥¼Â ì§„í–‰í•œë‹¤.Â **ìœ ì‚¬ ì¤‘ìœ„ ìˆœíšŒ**ë¥¼ ì§„í–‰í•˜ë©´ì„œ ì´ 10ë²ˆ ì´ë™í•˜ì˜€ë‹¤.

ì—¬ê¸°ì„œ ì´ë™ì´ë¼ëŠ” ê²ƒì€ í•˜ë‚˜ì˜ ë…¸ë“œì—ì„œ ë‹¤ë¥¸ ë…¸ë“œë¡œ í•œë²ˆ ì›€ì§ì´ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤. ì˜ˆë¥¼ ë“¤ë©´, ë…¸ë“œ 1ì—ì„œ ë…¸ë“œ 2ë¡œ ê°€ëŠ” ê²ƒì„ í•œë²ˆ ì´ë™í•˜ì˜€ë‹¤ê³  í•œë‹¤.

**ìœ ì‚¬ ì¤‘ìœ„ ìˆœíšŒ**ë¥¼ í•˜ë©´ì„œ ì´ë™í•œ íšŸìˆ˜ë¥¼ êµ¬í•˜ë ¤ê³  í•œë‹¤.

## ì…ë ¥

ì²« ë²ˆì§¸ ì¤„ì— íŠ¸ë¦¬ë¥¼ êµ¬ì„±í•˜ëŠ” ë…¸ë“œì˜ ê°œìˆ˜Â ğ‘$N$ì´ ì£¼ì–´ì§„ë‹¤.

ë‘ ë²ˆì§¸ ì¤„ë¶€í„°Â ğ‘+1$N + 1$Â ë²ˆì§¸ ì¤„ê¹Œì§€Â í˜„ì¬ ë…¸ë“œÂ ğ‘$a$, í˜„ì¬ ë…¸ë“œì˜ ì™¼ìª½ ìì‹ ë…¸ë“œÂ ğ‘$b$, í˜„ì¬ ë…¸ë“œì˜ ì˜¤ë¥¸ìª½ ìì‹ ë…¸ë“œÂ ğ‘$c$ê°€ ê³µë°±ìœ¼ë¡œ êµ¬ë¶„ë˜ì–´ ì£¼ì–´ì§„ë‹¤.Â ë§Œì•½ ìì‹ ë…¸ë“œì˜ ë²ˆí˜¸ê°€ -1ì¸ ê²½ìš° ìì‹ ë…¸ë“œê°€ ì—†ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤.

## ì¶œë ¥

ìœ ì‚¬ ì¤‘ìœ„ ìˆœíšŒë¥¼ í•˜ë©´ì„œ ì´ë™í•œ ì´ íšŸìˆ˜ë¥¼ ì¶œë ¥í•œë‹¤.

## ì œí•œ

- $1 \le N \le 100,000$â€Š
- â€Š$1 \le a, b \le N$

## í’€ì´

ë…¸ë“œ Nê°œì˜ ì´ì§„ íŠ¸ë¦¬ ìˆìŒ.

ì¤‘ìœ„ìˆœíšŒì™€ ìœ ì‚¬í•˜ê²Œ ìˆœíšŒí•˜ëŠ” ê²ƒì„ ìœ ì‚¬ ì¤‘ìœ„ ìˆœíšŒë¼ê³ í•¨.

ë£¨íŠ¸ ì‹œì‘

ì¤‘ìœ„ ìˆœíšŒ ë§ˆì§€ë§‰ ë…¸ë“œê°€ ë

ë£¨íŠ¸ ë…¸ë“œëŠ” 1ë²ˆ

1. ë£¨íŠ¸ -> ì™¼ìª½
2. ì™¼ìª½ ì—†ìœ¼ë©´ ë£¨íŠ¸ -> ì˜¤ë¥¸ìª½
3. ì˜¤ë¥¸ìª½ ì—†ê³  ëì´ë©´ ì¢…ë£Œ
4. ì˜¤ë¥¸ìª½ ì—†ê³  ë¶€ëª¨ë…¸ë“œ ì¡´ì¬í•˜ë©´ ë…¸ë“œ -> ë¶€ëª¨ë…¸ë“œ
5. 1~4 ë°˜ë³µ

ìœ ì‚¬ì¤‘ìœ„ìˆœíšŒí•˜ë©° ì´ë™í•œ íšŸìˆ˜ êµ¬í•´ì•¼ í•œë‹¤.

ì—¬ê¸°ì„œ ë°©ë¬¸ì—¬ë¶€ë¥¼ ì–´ë–»ê²Œ íŒë‹¨í–ˆëƒë©´, 
ìœ„ì—ì„œ ì•„ë˜ë¡œ ë‚´ë ¤ê°ˆë• íŒë‹¨í•˜ì§€ ì•Šê³ , ì•„ë˜ì—ì„œ ìœ„ë¡œ ì˜¬ë¼ê°ˆë•Œ (current node -> parents Node)ì¸ ê²½ìš°ë§Œ current nodeì˜ ë°©ë¬¸ì—¬ë¶€ë¥¼ trueë¡œ ë³€ê²½í•´ì£¼ì—ˆë‹¤.

ì™œëƒí•˜ë©´, ì•„ë˜ë¡œ ë‚´ë ¤ê°ˆë•ŒëŠ” ìœ„ë¡œ ë‹¤ì‹œ ë°©ë¬¸í•  ì—¬ì§€ê°€ ìˆê¸° ë•Œë¬¸.

ê·¸ëŸ¼ ë£¨íŠ¸ë…¸ë“œëŠ” ë°©ë¬¸ì—¬ë¶€ íŒë‹¨ì´ ì•ˆë˜ëŠ”ê±° ì•„ë‹ˆëƒ? ë¼ê³  í•  ìˆ˜ ìˆë‹¤.

ë§ë‹¤. ë£¨íŠ¸ë…¸ë“œëŠ” ì‹¤ì œë¡œ ë°©ë¬¸ì„ í•˜ë”ë¼ë„ ë°©ë¬¸ì—¬ë¶€ê°€ trueê°€ ì•ˆëœë‹¤.

ê·¼ë°, ìƒê´€ì—†ë‹¤.

ë‚œ ì‹¤ì œ ë°©ë¬¸ì—¬ë¶€ì— ëŒ€í•œ ì‚¬ì‹¤ì´ í•„ìš”í•œ ê²ƒì´ ì•„ë‹ˆë¼, ìœ ì‚¬ ì¤‘ìœ„ìˆœíšŒë¥¼ ìœ„í•œ ë°©ë¬¸ì—¬ë¶€ê°€ í•„ìš”í•œ ê²ƒì´ê¸° ë•Œë¬¸ì—, 

ìì‹ ë…¸ë“œë¥¼ ì¤‘ë³µ ë°©ë¬¸í•˜ì§€ ì•Šê²Œ í•˜ê¸° ìœ„í•œ ë°©ì§€ì±…ìœ¼ë¡œì¨ ì‚¬ìš©í–ˆë‹¤.(ê·¸ë˜ì„œ ìœ„ë¡œ ì˜¬ë¼ê°ˆë•Œë§Œ ë°©ë¬¸ì—¬ë¶€ë¥¼ trueë¡œ ë³€ê²½í•´ì£¼ì—ˆë‹¤.)



## í‹€ë¦° ì½”ë“œ


```java
package BaekJoon;  
  
import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStreamReader;  
  
public class BaekJoon22856 {  
    static Node[] nodes;  
    static boolean[] visited;  
    static int n;  
    public static void main(String[] args) throws IOException {  
  
        // input  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        n = Integer.parseInt(br.readLine());  
        nodes = new Node[100001];  
        visited = new boolean[n+1];  
        for(int i=1; i<=n; i++){  
            String[] input = br.readLine().split(" ");  
            int curNode = Integer.parseInt(input[0]);  
            int leftNode = Integer.parseInt(input[1]);  
            int rightNode = Integer.parseInt(input[2]);  
  
            if(nodes[curNode] == null) nodes[curNode] = new Node(leftNode, rightNode);  
            else{  
                nodes[curNode].leftIdx = leftNode;  
                nodes[curNode].rightIdx = rightNode;  
            }  
  
            if(leftNode != -1 ){  
                if(nodes[leftNode] == null)nodes[leftNode] = new Node();  
                nodes[leftNode].parentIdx = curNode;  
            }  
  
            if(rightNode != -1){  
                if(nodes[rightNode] == null){  
                    nodes[rightNode] = new Node();  
                }  
                nodes[rightNode].parentIdx = curNode;  
            }  
  
        }  
  
        // main logic  
        int cnt = solution(1, 0);  
  
        // output  
        System.out.println(cnt);  
  
  
  
  
    }  
  
    private static int solution(int nodeIdx, int cnt) {  
  
        if(nodes[nodeIdx].hasLeft() && !visited[nodes[nodeIdx].leftIdx] ){  
            return solution(nodes[nodeIdx].leftIdx, cnt+1);  
        }  
        else if(nodes[nodeIdx].hasRight() && !visited[nodes[nodeIdx].rightIdx]){  
            return solution(nodes[nodeIdx].rightIdx, cnt+1);  
        }  
        else if(nodeIdx == n){  
            return cnt;  
        }  
        else{  
            visited[nodeIdx] =true;  
            return solution(nodes[nodeIdx].parentIdx, cnt+1);  
        }  
    }  
  
    private static class Node{  
        int leftIdx;  
        int rightIdx;  
        int parentIdx = -1;  
  
        public Node(int leftIdx, int rightIdx){  
            this.leftIdx=leftIdx;  
            this.rightIdx=rightIdx;  
        }  
        public Node(){  
            this.leftIdx=-1;  
            this.rightIdx=-1;  
        }  
  
        private boolean hasLeft(){  
  
            return leftIdx != -1;  
        }  
  
        private boolean hasRight(){  
            return rightIdx != -1;  
        }  
    }  
}
```

ì²˜ìŒì—ëŠ” ìœ ì‚¬ ì¤‘ìœ„ ìˆœíšŒì˜ ì¡°ê±´ì— ë§ê²Œ ì½”ë“œë¥¼ ì‘ì„±í–ˆë‹¤.

ê·¸ëŸ¼ì—ë„ í‹€ë ¸ë‹¤.

ì´ìœ ë¥¼ ìƒê°í•´ë³´ë‹ˆ, ë§ˆì§€ë§‰ì˜ ë…¸ë“œì˜ ë²ˆí˜¸ë¥¼ ë‹¨ìˆœí•˜ê²Œ ë§ˆì§€ë§‰ ë²ˆí˜¸ë¼ê³  ìƒê°í–ˆê¸° ë•Œë¬¸ì´ë‹¤.

ë…¸ë“œì˜ ê°œìˆ˜ê°€ 7ê°œë¼ê³  í•´ì„œ ë§ˆì§€ë§‰ ë…¸ë“œì˜ ë²ˆí˜¸ê°€ 7ë²ˆì´ë¼ëŠ” ë³´ì¥ì€ ì—†ë‹¤.

ì¦‰, ê¸°ì¡´ ì¤‘ìœ„ìˆœíšŒë¥¼ í•œë²ˆ ëˆ ë‹¤ìŒ ë§ˆì§€ë§‰ ë…¸ë“œì˜ ë²ˆí˜¸ë¥¼ ì°¾ì•„ë‚´ì•¼ í•œë‹¤.

ê·¸ í›„ ë§ˆì§€ë§‰ ë…¸ë“œì— ëŒ€í•œ ì¡°ê±´ì„ ìœ ì‚¬ì¤‘ìœ„ìˆœíšŒ ë©”ì„œë“œì— ì ìš©ì‹œì¼œì£¼ë©´ëœë‹¤.

## ì½”ë“œ


```java
package BaekJoon;  
  
import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStreamReader;  
import java.util.ArrayList;  
import java.util.List;  
  
public class BaekJoon22856 {  
    static Node[] nodes;  
    static boolean[] visited;  
    static int n;  
    static List<Integer> inOrderStatus;  
  
    static int lastNode;  
    public static void main(String[] args) throws IOException {  
  
        // input  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        n = Integer.parseInt(br.readLine());  
        nodes = new Node[100001];  
        visited = new boolean[n+1];  
  
  
        for(int i=1; i<=n; i++){  
            String[] input = br.readLine().split(" ");  
            int curNode = Integer.parseInt(input[0]);  
            int leftNode = Integer.parseInt(input[1]);  
            int rightNode = Integer.parseInt(input[2]);  
  
            if(nodes[curNode] == null) nodes[curNode] = new Node(leftNode, rightNode);  
            else{  
                nodes[curNode].leftIdx = leftNode;  
                nodes[curNode].rightIdx = rightNode;  
            }  
  
            if(leftNode != -1 ){  
                if(nodes[leftNode] == null)nodes[leftNode] = new Node();  
                nodes[leftNode].parentIdx = curNode;  
            }  
  
            if(rightNode != -1){  
                if(nodes[rightNode] == null){  
                    nodes[rightNode] = new Node();  
                }  
                nodes[rightNode].parentIdx = curNode;  
            }  
  
        }  
  
        // main logic  
        inOrderStatus = new ArrayList<>();  
        inOrder(1);  
        lastNode = inOrderStatus.get(n-1);  
        int cnt = solution(1, 0);  
  
        // output  
        System.out.println(cnt);  
  
  
  
  
    }  
  
    private static int solution(int nodeIdx, int cnt) {  
  
        if(nodes[nodeIdx].hasLeft() && !visited[nodes[nodeIdx].leftIdx] ){  
            return solution(nodes[nodeIdx].leftIdx, cnt+1);  
        }  
        else if(nodes[nodeIdx].hasRight() && !visited[nodes[nodeIdx].rightIdx]){  
            return solution(nodes[nodeIdx].rightIdx, cnt+1);  
        }  
        else if(nodeIdx == lastNode){  
            return cnt;  
        }  
        else{  
            visited[nodeIdx] =true;  
            return solution(nodes[nodeIdx].parentIdx, cnt+1);  
        }  
    }  
  
    private static class Node{  
        int leftIdx;  
        int rightIdx;  
        int parentIdx = -1;  
  
        public Node(int leftIdx, int rightIdx){  
            this.leftIdx=leftIdx;  
            this.rightIdx=rightIdx;  
        }  
        public Node(){  
            this.leftIdx=-1;  
            this.rightIdx=-1;  
        }  
  
        private boolean hasLeft(){  
  
            return leftIdx != -1;  
        }  
  
        private boolean hasRight(){  
            return rightIdx != -1;  
        }  
    }  
  
    private static void inOrder(int cur) { // in-order(ì¤‘ìœ„ ìˆœíšŒ)  
        Node curNode = nodes[cur];  
        int left = curNode.leftIdx;  
        int right = curNode.rightIdx;  
  
        if (left != -1) {  
            inOrder(left);  
        }  
  
        inOrderStatus.add(cur);  
  
        if (right != -1) {  
            inOrder(right);  
        }  
    }  
}
```