## 문제

N개의 수로 이루어진 1차원 배열이 있다. 이 배열을 M개 이하의 구간으로 나누어서 구간의 점수의 최댓값을 최소로 하려고 한다. 구간은 다음과 같은 조건을 만족해야 한다.

1. 하나의 구간은 하나 이상의 연속된 수들로 이루어져 있다.
2. 배열의 각 수는 모두 하나의 구간에 포함되어 있어야 한다.

구간의 점수란 구간에 속한 수의 최댓값과 최솟값의 차이이다.

예를 들어, 배열이 \[1, 5, 4, 6, 2, 1, 3, 7] 이고, M = 3인 경우가 있다.

이때, \[1, 5], \[4, 6, 2], \[1, 3, 7]로 구간을 나누면 각 구간의 점수는 4, 4, 6점이 된다. 이때, 최댓값은 6점이다.

만약, \[1, 5, 4], \[6, 2, 1], \[3, 7]로 구간을 나누었다면, 각 구간의 점수는 4, 5, 4점이 되고, 이때 최댓값은 5점이 된다.

두 경우 중에서 최댓값이 최소인 것은 5점인 것이고, 5점보다 최댓값을 작게 만드는 방법은 없다.

배열과 M이 주어졌을 때, 구간의 점수의 최댓값의 최솟값을 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 배열의 크기 N과 M이 주어진다. (1 ≤ N ≤ 5,000, 1 ≤ M ≤ N)

둘째 줄에 배열에 들어있는 수가 순서대로 주어진다. 배열에 들어있는 수는 1보다 크거나 같고, 10,000보다 작거나 같은 자연수이다.

## 출력

첫째 줄에 구간의 점수의 최댓값의 최솟값을 출력한다.

## 예제 입력 1 복사

8 3
1 5 4 6 2 1 3 7

## 예제 출력 1 복사

5

## 풀이

### 문제 이해

N개의 수로 이루어진 1차원 배열이 존재한다.

이 1차원 배열을 M개 이하의 구간으로 나눈다.

나눴을 때 구간의 점수의 최댓값을 최소로 하려고 한다.

Upper bound 이분탐색을 진행해야 할 것 같고, "구간의 점수의 최댓값"이 이분탐색 기준이 되겠다.

left-1 값을 결과로 출력하면 될 것 같다.

해당 문제에 조건이 첨부되어있다.

1. 하나의 구간은 하나 이상의 "연속된 수"들로 이루어져 있다.
여기서 연속된 수는 배열을 정렬하지 말고, 그대로 뒀을 때 index가 연속된다는 의미이다.
그리고 모든 배열은 항상 1개 이상의 원소를 가지고 있어야한다.

2. 배열의 각 수는 모두 하나의 구간에 포함되어 있어야 한다.
배열의 원소는 반드시 구간에 포함되어있어야 한다.

구간의 점수는 무엇인가?

구간에 속한 수의 최댓값과 최솟값의 차이이다.

변수명은 sectionDiff 로 하면 될 것 같다.

해당 구간 점수를 구하는 메소드 명은 findSectionDiff로 하자.

파라미터는 배열만 받고 리턴타입은 값의 범위가 크지 않는이상 int로 하면 될 것 같다.

### 입력

N M 을 첫째줄에 받는다.

N은 배열 원소 수, M은 나눌 구간 수이다.

String타입의 Array로 받고, 해당 값을 static 메소드인 Integer.parseInt()로 형변환 해주면 될 것 같다.

둘째 줄에 배열에 들어있는 수가 순서대로 받아진다.

수의 범위는 1 이상 10,000이하 자연수이다.

### 출력

첫째 줄에 구간의 점수의 최댓값의 최솟값을 출력해야 한다.

### 해결 전략

"구간의 점수의 최댓값"을 구하는 메서드가 필요하다.
"각 구간의 점수"을 구하는 메서드 또한 필요하다.

그렇다면 "구간의 점수의 최댓값"의 최솟값은 어떻게 구해야 할까?

"구간의 점수의 최댓값"을 기준으로 이분탐색을 한다면 범위는 어떻게 될까?

"구간의 점수의 최댓값"의 최대값은 배열의 원소의 `최댓값 - 최솟값` 이다.

최솟값은 값이 중복되지 않는다는 말이 없으므로, 0이다.

만약 5000이 최댓값일때 만들 수 있는 구간은 몇개인가?로 찾으면 될 것 같다.

그래서 주어진 구간(M)과 같아지는 순간 멈추면 될 것 같다.

그럼 "구간의 점수의 최댓값"이 주어졌을 때 "만들 수 있는 구간"을 어떻게 구할까?

### 구간 수 구하기

만들 수 있는 구간을 어떻게 구할까? 

구간이 어떻게 만들어질까 라는 방향성을 먼저 잡아보자.

거꾸로 생각해보면 구간은 구간 내 최소값과 최댓값의 차가 "구간의 점수의 최댓값"보다 작아야 한다.

우리는 "구간의 점수의 최댓값"을 임시로 구해놓았다.

그렇다면 배열을 돌면서 해당 인덱스까지의 최솟값과 최댓값을 계속해서 업데이트 하면 구간을 구할 수 있다.

`1,4,3,1,5` 라는 배열이 있다고 해보자.

"구간의 점수의 최댓값"이 2라고 가정해보자.

1에서 시작했을 때는 문제가 없다. 최솟값과 최댓값이 모두 1이기 때문에 "구간의 점수의 최댓값"은 0이 된다.

1-> 4으로 넘어갔을 땐, 최솟값=1, 최댓값=4, 차이의 최댓값 = 3가된다.

"구간의 점수의 최댓값"은 2이므로 구간으로 만들 수 없다.

그렇다면 1에서 끊는다.

다시 4에서부터 반복문을 돌린다.

4를 구간으로 만들면 문제가 없다.

4->3 으로 해도 차이의 최댓값은 1이므로 문제가 없다.

4->3->1로 하면 차이의 최댓값은 3이 된다. 문제가 생긴다.

4,3 을 하나의 구간으로 만든다.

1부터 다시 반복문을 돌린다.

1 자체는 구간으로 만들어도 문제가 없다.

1 -> 5 는 구간으로 만들면 차이의 최댓값이 4가 되므로 문제가 생긴다.

1 자체를 구간으로 만든다.

5부터 다시 돌린다.

결론적으로 생기는 구간은 1 | 4, 3 | 1 | 5 가 된다.

총 4개의 구간이 생긴다.

만든 구간이 M보다 작은지 판단한다.

만약 작다면 구간을 늘려야 하므로 "구간의 점수의 최댓값"을 줄여야 한다.

크다면 구간을 줄여야 하므로 "구간의 점수의 최댓값"을 늘려야 한다.

이러한 방식으로 문제를 해결하면 될 것 같다.

마지막으로 궁금한 점이 있을 수 있다.

왜 구간 수를 늘리려면 "구간의 점수의 최댓값"을 줄여야 하는가?

구간의 점수는 해당 구간의 `최댓값-최솟값` 이다.

"구간의 점수의 최댓값"은 `최댓값-최솟값`의 허용가능한 범위이다.

만약 "구간의 점수의 최댓값"을 늘린다면?

`최댓값-최솟값` 범위가 늘어난다. == 굳이 구간으로 만들지 않아도 된다.

반대의 경우는 구간으로 반드시 만들어야 한다.

그렇기 때문에 "구간 수"를 늘리기 위해서는 "구간의 점수의 최댓값"을 줄여야 한다.


## 코드


```java
package BaekJoon;  
  
import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStreamReader;  
import java.util.Arrays;  
  
public class BaekJoon13397 {  
  
    private static int n, m;  
    private static int[] arr;  
    private static int result;  
    public static void main(String[] args) throws IOException {  
  
        // input  
        input();  
  
        // main logic  
        solution();  
  
        // output  
        System.out.println(result);  
    }  
  
    private static void solution() {  
  
        int left = 0;  
        int right = Arrays.stream(arr).max().getAsInt();  
  
        // upper bound  
        while(left < right){  
  
//            System.out.println("left : " + left  + ", right : " + right);  
  
            int mid = (left+right) /2 ; // 임시로 구한 "구간내 최솟값과 최댓값의 차이의 최댓값"  
  
            if(findSectionNum(mid) <= m){  
                // mid가 커질 수록 구간 수가 감소한다. 즉, mid를 줄여야 한다.  
                right = mid;  
            }else{  
                // 만약 findSection                left = mid + 1;  
  
            }  
        }  
  
        result = left;  
  
  
    }  
  
    private static int findSectionNum(int mid) {  
  
        int min = Integer.MAX_VALUE;  
        int max = Integer.MIN_VALUE;  
  
        int sectionNum = 1;  
        for(int i =0; i<arr.length; i++){  
            min = Math.min(min, arr[i]);  
            max = Math.max(max, arr[i]);  
  
            if(Math.abs(max-min) > mid ){  
                sectionNum ++;  
                min = arr[i];  
                max = arr[i];  
            }  
        }  
  
//        System.out.println(" section Num = " + sectionNum);  
  
        return sectionNum;  
  
    }  
  
    private static void input() throws IOException{  
  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        String[] input = br.readLine().split(" ");  
  
        n = Integer.parseInt(input[0]);  
        m = Integer.parseInt(input[1]);  
  
        arr = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();  
  
    }  
}
```