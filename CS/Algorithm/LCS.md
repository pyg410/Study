Longest Common Subsequence, Longest Common Substring 을 말한다.
최장 공통 부분수열, 최장 공통 문자열을 말하기도 한다.

ABCDEF와 GBCDFE를 이용해 차이점을 예시로 들어보면

![](https://i.imgur.com/nwjISi4.png)
Longest Common Subsequence(최장 공통 부분수열)의 경우 공통 부분인 BCDF를,

Longest Common Substring의 경우 BCD를 출력하게 된다.

부분수열이기 때문에 문자사이를 건너 뛸 수 있는 것이고,

공통 문자열의 경우 이어져있는 문자열인 BCD를 출력하는 것이다.


## 최장 공통 문자열(Longest Common Substring)

### 점화식

```
if i==0 or j==0:
	LCS[i][j] = 0
elif string_A[i] == string_B[j]:
	LCS[i][j] = LCS[i-1][j-1] + 1
else:
	LCS[i][j] = 0
```
LCS라는 2차원 배열을 이용하여 두 문자열을 행, 열에 매칭한다.
편의상 i,j가 0일때는 모두 0을 넣어줘 마진값을 설정한다.
이후 i,j가 1 이상일때부터 검사를 시작한다.

1. 문자열 A, 문자열 B의 한글자씩 비교해본다.
2. 두 문자가 다르다면 LCS\[i]\[j]에 0을 표시한다.
3. 두 문자가 같다면 LCS\[i-1]\[j-1] 값을 찾아 +1 한다.
4. 위 과정을 반복한다.

위 과정이 성립하는 이유는 공통 문자열은 연속되어야 하기 때문이다.
현재 두 문자가 같을 때 두 문자의 앞글자까지가 공통 문자열이라면 계속 공통 문자열이 이어질 것이고, 아니라면 본인부터 다시 공통 문자열을 만들어 가게 될 것이다.

## 최장 공통 부분수열(Longest Common Subsequence)

다른 LCS인 최장 공통 부분수열을 구해보자.

### 점화식

```
if i==0 or j==0:
	LCS[i][j] = 0
elif string_A[i] == string_B[j]:
	LCS[i][j] = LCS[i-1][j-1] + 1
else:
	LCS[i][j] = max(LCS[i-1][j], LCS[i][j-1])
```
위와 마찬가지로 LCS라는 2차원 배열에 매칭하고 마진값을 설정한 후 검사한다.
1. 문자열A, 문자열B의 한글자씩 비교해본다.
2. 두 문자가 다르다면 `LCS[i-1][j]`와 `LCS[i][j-1]`중에 큰 값을 표시한다.
3. 두 문자가 같다면 `LCS[i-1][j-1]`값을 찾아 +1 한다.
4. 위 과정을 반복한다.

최장 공통 문자열을 구하는 과정과 다른 부분은 비교하는 두 문자가 다를 때 이다.

## 최장 공통 부분수열(Longest Common Subsequence) 찾기

이제 만든 LCS 배열을 이용해 최장 공통 부분수열의 값을 찾는 방법을 설명한다. 
경우에 따라 여러가지 답이 나올 수 있기 때문에 아래 예시는 한가지 경우만을 설명한다.

과정은 다음과 같다.

1. LCS 배열의 **가장 마지막 값**에서 시작합니다. 결과값을 저장할 `result` 배열을 준비한다.
2. `LCS[i - 1][j]`와 `LCS[i][j - 1]` 중 현재 값과 같은 값을 찾는다.  
    2-1. 만약 **같은 값이 있다면 해당 값으로 이동**한다.  
    2-2. 만약 **같은 값이 없다면 `result`배열에 해당 문자를 넣고 `LCS[i -1][j - 1]`로 이동**한다.
3. 2번 과정을 반복하다가 0으로 이동하게 되면 종료합니다. `result` 배열의 역순이 **LCS** 이다.