## 개요

디웨일 면접을 보면서 부동소수점에 대한 질문을 받았다.
어떻게 구성되고 표현되는지 질문했는데 정확하게 답변하지 못해 정리해본다.

## 소수점을 변환하는 방법

인간은 10진수를 사용하고 표현하지만, 컴퓨터는 0과 1로 이루어진 기계어를 사용한다.
그러므로 컴퓨터가 수를 표현하는 법에 대해 이야기하려면 10진수를 2진수로 바꾸는 법에 대해 알아야 한다.

정수의 경우 예를 들어 5를 2진수로 바꿔보자
5/2 -> 1
4/2 -> 0
2/2 -> 0
1/2 -> 1
5(10)은 1001(2)로 변환된다.(아래에서부터 위로 읽으면 된다.)

그렇다면, 1.9는 어떻게 표현할까?
정수부인 1은 위와 같이 변환하면 되지만, 0.9인 소수부는 어떻게 변환해야할까?
단순하게 정수부를 변환하는 것처럼 숫자를 2진수로 나누면 될까?

안된다. 소수부는 정수부 변환의 정반대로 해야한다.
정수부의 경우 10진수를 2로 나눠가면서 1이나 0으로 변환했다면, 소수부는 10진수에 2를 곱해가면서 1이나 0으로 변환해야한다.

0.625의 경우
0.625 * 2 = 1.25 -> 1을 빼내고 나머지 0.25
0.25 * 2 = 0.5 -> 0을 빼내고 나머지 0.5
0.5 * 2 = 1 -> 1을 빼내고 나머지 0
0이 나오면 변환을 종료하고 변환한 숫자를 위에서부터 아래로 읽으면 된다.
즉, 0.625(10)은 0.101(2)이 된다.

## 고정소수점

영어로는 floating point이다.
소수점이 둥둥 떠다닌다고 번역할 수 있겠다.

고정 소수점 표현은 10진수를 2진수로 바꿨다면, 소수점의 위치를 고정하여 표현하는 방식이다.
7.625라는 실수가 있으면, 2진수로 변환하면 111.101이 된다.
![](https://i.imgur.com/IN0KwVR.png)
16비트 체계를 쓴다고 가정하면,
맨 앞 1자리는 Sign Bit이며, 0이면 양수 1이면 음수이다.
나머지 비트는 소수점을 기준으로 정수부와 소수부를 표현하는 비트로 각 나누게 된다.
고정 소수점 표현방식이기 때문에 소수점은 고정한다.

이러한 고정 소수점 방식은 구현하기 편하지만, 사용하는 비트 수 대비 표현가능한 수의 범위 또는 정밀도가 낮기 때문에 범용 시스템에서 거의 사용되지 않는다.

정밀도란 신뢰가능한 표현 범위를 의미한다.

## 부동소수점

부동 소수점 표현 방식은 고정 소수점 방식에서 몇 가지 과정이 추가된다.

정규화란, 2진수를 1.xx \* 2^n 와 같이 변환하는 것을 의미한다.

변환하는 방법은, 정수부에 1만 남을 때까지 소수점을 왼쪽으로 이동시키고, 이동한 칸 수만큼 n자리에 집어 넣으면 된다.
111.101을 정규화하면, 1.11101 \* 2^2가 된다.

## IEEE 754 부동소수점 표현

IEEE 표준에 따르면 부동소수점 방식으로 실수를 저장하는 데는 32비트, 또는 64비트가 사용되며 32비트 기준으로 아래 그림과 같은 구조를 따른다.
![](https://i.imgur.com/EiixJNp.png)
부호 비트는 고정 소수점에서와 마찬가지로 0은 양수 1은 음수이다.
23자리 가수부는 정규화 결과, 소수점 오른쪽에 있는 숫자들을 왼쪽부터 그대로 넣으면 된다. 남는 자리는 0으로 채운다.
(참고: 소수점 왼쪽은 정규화를 하면 무조건 1이기 때문에 신경쓰지 않고 표현도 안 하는데, 이 1을 hidden bit라고 부르기도 한다)


남는건 8자리 지수부인데, '지수'부라는 이름은 2^n에서 n에 해당하는 수이다.
예시에서는 2^2에서 오른쪽 2를 2진수로 바꾼 10(2)을 넣으면 된다.
하지만 IEEE 표준에 따르면 지수부에 지수를 그대로 넣는게 아닌, 'bias'라고 하는 지정된 숫자를 더한 다음 넣어야 한다.
IEEE 표준에서 32bit 기준 bias는 127로 규정한다.
그러므로 2+ 127인 129를 2진수로 바꾼 10000001(2)이 들어간다.
결론적으로 7.625는 컴퓨터에서 아래와 같이 저장된다.
![](https://i.imgur.com/d6gjOxf.png)


## bias를 쓰는 이유
> 이 bias라는 값을 왜 쓰냐면, 지수가 음수가 될 수도 있어서 그렇다.
>
예를 들면 0.000101이라는 이진수가 있다 치자. 정규화에 대해서 설명할 때 정수부를 1로 만들어야 한다고 했다. 그러니까 왼쪽이 아니라 오른쪽으로 소수점을 밀어서 1.01 * 2^-4가 된다.
>
 > 
>
만약에 bias가 없어서 위에서 2를 그냥 00000010으로 저장했다고 생각해보자. -4는 어떻게 저장할래?
>
부호 비트는 지수의 부호를 뜻하는게 아니라 전체 숫자의 부호를 뜻하는 거라서 이거랑 상관이 없다.
>
그렇다고 지수용 부호 비트를 하나 더 만들자니 이것대로 복잡하다. 그래서 8자리를 가지고 음수랑 양수를 둘 다 표현하자니, (10진수 기준으로) 0~127 구간은 음수, 128~255 구간은 양수를 표현하도록 만든 것이다.

(참고: 실제로는 0이랑 255는 0이나 0에 한없이 수렴하는 작은 수들, 무한대, NaN -Not a Number- 같은 걸 표현하기 위해서 특별하게 지정되어 있기 때문에 일반적인 표현 범위에 포함되지 않으며, 저런 수들을 표현할 때는 이 글에서 설명한 정규화 방법이 적용되지 않는다)

  

위 그림에서 살펴본 32비트 체계를 32비트 단정도 (Single-Precision), 64비트 체계를 64비트 배정도 (Double-Precision) 이라고 부른다. 

그리고 프로그래밍 언어를 다뤄봤다면 흔히 접할 수 있는 실수형 타입 float, double이 각각 전자, 후자에 해당한다. float는 부동소수점 방식을 사용하는 기본형이라는 의미로 floating point에서 따왔고, double은 64비트 배정도를 사용한다는 의미로 double-precision에서 따왔을 것이다.

  

double, 그러니까 64비트 체계에서는 지수부가 11비트, 가수부가 52비트다. 지수부가 2^11 즉 2048개의 수를 표현할 수 있으므로 0~1023 구간은 음수, 1024~2047 구간은 양수 지수를 의미하며 bias는 1023이 된다.

  

이와 같은 부동소수점 표현 방식은 위에서 살펴본 고정소수점 표현 방식에 비해서 비트 수 대비 표현 가능한 수의 범위와 정밀도 측면에서 보다 우위에 있기 때문에, 정규화니 bias니 하는 복잡한 과정이 들어감에도 불구하고 현재 대부분의 컴퓨터 시스템에서 부동소수점을 이용해 실수를 표현하고 있다.

출처: [https://gsmesie692.tistory.com/94](https://gsmesie692.tistory.com/94) [환상빛 별하늘: Reb∞t:티스토리]

## 부동소수점 오차


0.1 * 2 = 0.2 -> 0
0.2 * 2 = 0.4 -> 0
0.4 * 2 = 0.8 -> 0
0.8 * 2 = 1.6 -> 1
0.6 * 2 = 1.2 -> 1
0.2 * 2 = 0.4 -> 0
...
즉, 0.1을 2진수로 변경할 시, 무한히 반복되는 문제가 발생한다.

\0. 000110...
이러한 
32bit의 경우, 표현하면
오른쪽으로 4번 이동하므로,
1.100110 ... * 2^-4 가 된다.
1 01111100 100110... 23bit인 가수부를 꽉 채우게 된다.
128 - 4이므로 124가 지수부를 채우게 되고, 나머지는 23bit 가수부를 채우게 되는거다.

이 때문에 특정 소수점 이하는 생략하고 가장 비슷한 숫자로 표현하게 된다.

실제 자바에서도 1.1+0.1을 하는 순간,
1.2000000000000002 가 출력된다.
부동소수점에 대한 오차가 발생하는 것.



