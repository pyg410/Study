## 명령어 파이프라인(Instruction Pipeline)

명령어 처리 과정을 클럭 단위로 나누면 다음과 같다.
1. 명령어 인출(Instruction Fetch)
2. 명령어 해석(Instruction Decode)
3. 명령어 실행(Execution Instruction)
4. 결과 저장(Write Back)
물론, `명령어 인출 -> 명령어 실행`으로 나누기도 하고, `명렁어 인출 -> 명령어 해석 -> 명령어 실행 -> 메모리 접근 -> 결과 저장` 으로 나누기도 한다.

중요한 점은 같은 단계가 겹치지만 않는다면 CPU는 각 단계를 동시에 실행할 수 있다는 것이다.

예를 들어, CPU가 한 명령어를 '인출'하는 동안 다른 명령어를 '실행'할 수도 있다.

이렇게 공장 생산라인과 같은 명령어들을 `명령어 파이프라인`이라고 한다.

그리고, 명령어를 `명령어 파이프라인`에 넣고 동시에 처리하는 과정을 `명령어 파이프라이닝`이라고 한다.

## 파이프라인 위험(pipeline hazard)

파이프라이닝이 높은 성능을 가져오지만, 특정 상황에서 성능 향상에 실패하는 경우를 말한다.
1. 데이터 위험
2. 제어위험
3. 구조적 위험
위의 3가지로 나뉜다.

### 데이터 위험

데이터 위험(data hazard)는 명령어 간 `데이터 의존성`에 의해 발생한다.

예를 들어 어떤 명령어가 이전 명령어를 끝까지 실행해야만 비로소 실행할 수 있는 경우가 존재한다.


```
명령어1 : R1 <- R2 + R3 // R2+R3 값을 R1에 저장한다.
명령어2 : R4 <- R1 + R5 // R1+R5 값을 R4에 저장한다.
```
위의 경우 명령어 1을 수행해야만 명령어 2를 수행할 수 있다.
따라서 명령어 2는 명령어 1의 데이터에 의존적이다.
이러한 명령어들을 동시에 실행하려 하면 파이프라인이 제대로 동작하지 않을 수 있다.
이걸 데이터 위험이라고 한다.

### 제어 위험

제어 위험(control hazard)는 프로그램 카운터의 갑작스런 변화에 의해 발생한다.
Program Counter는 보통 현재 실행 중인 명령어의 다음 주소로 갱신된다.
하지만, 프로그램 실행 흐름이 바뀌어 명령어가 실행되면서 프로그램 카운터에 변화가 생긴다면 명령어 파이프라인에 미리 가지고와서 처리 중이었던 명령어들이 쓸모 없게 된다.

이를 제어 위험이라고 한다.

A인출 -> A해석 & B인출 -> A실행 & B해석 & C인출

명령어 파이프 라인이 위와 같이 되어있다면, A실행 단계에서 B1로 분기해야되는 명령어가 실행되면서 B와 C가 쓸모 없게 되는 경우이다.

이를 예방하기 위해 `분기예측(branch prediction)`이라는 기술이 사용된다.

### 구조적 위험

구조적 위험(structural hazard)은 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, Register를 사용하는 경우 발생한다.

이는, 자원 위험(resource hazard)라고도 부른다.