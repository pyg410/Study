# 연산코드와 오퍼랜드

## 명령어는 어떻게 구성되어있나요?

명령어는 연산 코드와 오퍼랜드로 구성되어있습니다.

## 연산코드는 무엇인가요?

명령어가 수행할 연산을 의미합니다.

Operation Code라고 합니다.

연산코드는 연산코드 필드에 담깁니다.

```nasm
push rbp
```

해당 코드에서 push가 연산 코드입니다.

## 오퍼랜드란 무엇인가요?

Operand라고 하며, `연산에 사용할 데이터` 또는 `연산에 사용할 데이터가 저장된 위치`를 오퍼랜드라고 합니다

오퍼랜드는 오퍼랜드 필드에 담깁니다.

```nasm
push rbp
```

해당 코드에서 rbp가 오퍼랜드입니다.

오퍼랜드 필드에는 데이터 또는 메모리, 레지스터 주소가 올 수 있습니다.

많은 경우 연산에 사용할 데이터가 저장된 위치, 즉 메모리 주소나 레지스터 이름이 담깁니다.

그래서 오퍼랜드 필드를 주소 필드라고 부르기도 합니다.

오퍼랜드는 명령어 안에 하나도 없을 수도 있고, 한 개만 있을 수도 있고, 두 개 또는 세 개 등 여러 개가 있을 수도 있습니다.

## 0~3 주소 명령어에 대해 설명해주세요.

앞에 있는 0~3의 경우 오퍼랜드의 개수를 의미합니다.

오퍼랜드가 없는경우 0-주소 명령어

오퍼랜드가 3개인 경우 3-주소 명령어라고 합니다.

## 연산코드의 유형을 4가지 말해주세요

연산코드 종류는 매우 많지만, 기본적으로 4가지로 나뉩니다.

- 데이터 전송

데이터 전송의 경우 대표적으로 MOVE, STORE, LOAD, PUSH, POP 등이 있습니다.

- 산술/논리 연산

산술 논리 연산은 ADD, SUBTRACT, MULTIPLY, INCREMENT, AND, COMPARE 등이 있습니다.

- 제어흐름 변경

JUMP, CONDITIONAL JUMP, HALT, CALL, RETURN 등이 있습니다.

- 입출력 제어

READ, WRITE, START IO, TEST IO 등이 있습니다

## 오퍼랜드 필드에 메모리나 레지스터의 주소를 담는 이유를 알려주세요

연산코드 / 연산코드에 사용될 데이터 형식으로 명령어를 구성하지 않는이유는,

명령어 길이 때문입니다.

하나의 명령어는 n비트로 구성되어있습니다.

그 중 연산 코드 필드가 m비트라면, 1-주소 명령어라고 하더라도 오퍼랜드 필드의 길이는 n-m 비트가 됩니다.

2, 3 주소명령어가 된다면 오퍼랜드 필드의 길이는 더 줄어들게 됩니다.

예를들어 명령어 크기가 16비트이고, 연산코드 필드가 4비트인 2-주소 명령어에서 오퍼랜드 필드당 6비트정도밖에 남지 않습니다.

즉, 하나의 오퍼랜드 필드로 표현 가능한 정보의 가짓수는 2^6밖에 되지 않습니다.

만약 오퍼랜드 필드 안에 메모리 주소가 담긴다면, 표현할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커집니다.

예를들어 16비트를 저장할 수 있는 메모리가 있다면?

4비트크기의 오퍼랜드에 메모리 주소를 저장하는 것만으로도 하나의 오퍼랜드에 담을 수 있는 데이터가 메모리 크기인 16비트로 늘어나는 것이기 때문입니다 → 포인터 개념이라고 생각하면 편할 듯

## 연산의 대상이 되는 데이터가 저장된 위치를 뭐라고 하나요?

유효 주소라고 합니다.

연산 코드에 사용할 데이터가 저장된 위치를 의미합니다.

## 오퍼랜드 필드에 데이터가 저장된 위치를 찾는 방법은 무엇인가요?

주소 지정 방식은 유효주소를 찾는 방법입니다.

대표적인 주소지정 방식에는, 즉시 주소 지정 방식, 직접 주소 지정 방식, 간접 주소 지정 방식, 레지스터 주소지정 방식, 레지스터 간접 주소 지정 방식이 있습니다.

## 즉시 주소 지정 방식에 대해 설명해주세요.

즉시 주소 지정 방식은 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식입니다.

장점으로는 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없기 때문에 타 방식에 비해 빠릅니다.

단점으로는 표현할 수 있는 데이터의 크기가 작아집니다.

## 직접 주소 지정 방식에 대해 설명해주세요

오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식입니다.

오퍼랜드 필드 → 메모리(데이터)

장점으로는 오퍼랜드 필드에서 표현가능한 데이터 크기가 늘어납니다.

한계로는 여전히 유효주소 표현가능 범위가 연산코드의 비트 수만큼 줄어듭니다.

## 간접주소지정방식에 대해 설명해주세요.

간접주소지정방식은 유효주소의 주소를 오퍼랜드 필드에 명시합니다.

오퍼랜드 필드 → 메모리(유효주소) → 메모리(데이터)

→ 아마 메모리에 쓸 수 있는 유효주소 범위가 더 넓기 때문

장점으로는 직접주소지정 방식보다 표현할 수 있는 유효주소의 범위가 더 넓어집니다.

단점으로는 두 번의 메모리 접근이 필요하기 때문에 앞서 설명한 주소 지정 방식들보다 느립니다.

## 레지스터 주소 지정 방식에 대해 설명해주세요

직접주소지정방식돠 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방식입니다.

장점으로는 CPU외부에 있는 메모리보다 CPU내부의 레지스터 접근이 더 빠르기 때문에 데이터 접근이 빨라집니다.

단점으로는 표현할 수 있는 레지스터 크기에 제한이 생길 수 있습니다.(오퍼랜드 표현 비트수의 한계)

## 레지스터 간접 주소 지정 방식에 대해 설명해주세요

레지스터 간접 주소 지정 방식은 연산에 사용할 데이터를 메모리에 저장하고, 유효주소를 레지스터에 저장한 후, 레지스터의 주소를 오퍼랜드 필드에 명시하는 방법입니다.

장점으로는 메모리에 접근하는 횟수가 한 번으로 줄어듭니다. 이로써 간접주소지정방식보다 더 빠릅니다.

## 정리

즉시주소지정방식 : 오퍼랜드(데이터)

직접주소지정방식 : 오퍼랜드(메모리 주소/유효주소) → 메모리(데이터)

간접주소지정방식 : 오퍼랜드(유효주소의 주소) → 메모리(유효주소) → 메모리(데이터)

레지스터주소지정방식 : 오퍼랜드(레지스터 주소/유효주소) → 레지스터(데이터)

레지스터간접주소지정방식 : 오퍼랜드(유효주소의 주소) → 레지스터(유효주소) → 메모리(데이터)