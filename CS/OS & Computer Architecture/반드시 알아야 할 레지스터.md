1. 프로그램 카운터
2. 명령어 레지스터
3. 메모리 주소 레지스터
4. 메모리 버퍼 레지스터
5. 플래그 레지스터
6. 범용 레지스터
7. 스택 포인터
8. 베이스 레지스터

## 프로그램 카운터
PC : Program Counter
메모리에서 가져올 `명령어의 주소`를 저장한다.
프로그램 카운터를 명령어 포인터(IP : Instruction Pointer)라고 부르기도 한다.

## 명령어 레지스터
IR : Instruction Register
메모리에서 읽어들인 `명령어를 저장`하는 레지스터이다.
제어장치는 해당 레지스터 속 명령어를 받아들이고 해석한 후 제어 신호를 내보낸다.


## 메모리 주소 레지스터
MAR : Memory Address Register
메모리의 주소를 저장하는 레지스터이다.
읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거치게 된다.

## 메모리 버퍼 레지스터
MBR : Memory Buffer Register
메모리와 주고받을 값인 데이터나 명령어를 저장하는 레지스터이다.
메모리에 쓰고싶은 값 or 메모리로부터 전달받은 값은 메모리 버퍼 레지스터를 거치게 된다.
예) CPU가 주소 버스로 내보낼 값이 메모리 주소 레지스터를 거치면, 데이터 버스로 주고받을 값은 메모리 버퍼 레지스터를 거치게 된다.

## 이해를 위한 예시
1. CPU로 실행할 프로그램이 1000번지 ~ 1500번지까지 저장되어 있다고 가정하자.
   1000번지에는 1101(2)가 저장되어있다.

2. 프로그램을 처음부터 시작하기 위해 프로그램 카운터에는 1000이 저장된다.(메모리 주소) 이는 메모리에서 가져올 명령어가 1000번지에 있다는 것을 의미한다.

3. 1000번지를 읽어들이기 위해 주소버스로 1000번지를 내보내야 한다. 이를 위해 메모리 주소 레지스터에는 1000이 저장된다.

4. 메모리 읽기 제어신호와 메모리 주소 레지스터 값이 각각 제어버스와 주소버스를 통해 메모리로 보내진다.

5. 메모리 1000번지에 저장된 값은 데이터 버스를 통해 메모리 버퍼 레지스터로 전달되고, 프로그램 카운터는 증가되어 다음 명령어를 읽어들일 준비를 한다.

6. 메모리 버퍼 레지스터에 저장된 값은 명령어 레지스터로 이동한다.

7. 제어장치는 명령어 레지스터의 명령어를 해석하고 제어 신호를 발생시킨다.

## 요약
- 프로그램 카운터 : 메모리에서 읽어들일 명령어 주소(메모리에서 읽어들일려면 프로그램 카운터 -> 메모리 주소 레지스터로 명령어 주소가 이동됨)
- 메모리 주소 레지스터 : 메모리에 요청보낼 때 참조할 주소 저장공간(주소버스에 담길 때 참조함)
- 메모리 버퍼 레지스터 : 실제로 읽어들인 메모리의 데이터 혹은 명령어가 저장되는 레지스터
- 명령어 레지스터 : 메모리 버퍼 레지스터에 저장된 명령어를 실행시키기 위해서 읽어들인 명령어가 이 레지스터로 옮겨짐.

## 순서
프로그램 카운터 -> 메모리주소 레지스터 -> 제어버스 & 주소 버스 -> 메모리 -> 데이터버스 -> 메모리 버퍼 레지스터 (프로그램 카운터 증가) -> 명령어 레지스터 -> 제어장치 -> 제어신호 발생

## 범용 레지스터
General Purpose Register
일반적인 상황에서 자유롭게 사용할 수 있는 레지스터이다.
메모리 주소 레지스터가 주소 버스로 내보낼 주소만 저장하고, 메모리 버퍼 레지스터가 데이터 버스로 주고 받을 값만 저장한다면, 범용 레지스터는 데이터와 주소 모두 저장할 수 있다.

## 플래그 레지스터
ALU연산 결과에 따른 플래그를 플래그 레지스터에 저장할 수 있다.
연산결과 도는 CPU상태에 대한 부가적인 정보를 저장한다.

